"""
Plotting tool for various aspects of autoencoder output.

Usage:
    python3 utiltiies/plot_ae.py <exp_dirs> --fields <field_1> <field_2> <etc>

    where <exp_dirs> is one or more base directories for different autoencoders
    (containing loss_log.txt files), and fields are anything recorded by
    gnina_autoencoder.py in log_loss.txt. Common fields include:

        loss
        disc_loss
        gen_loss
        nonzero_mae
        zero_mae
        nonzero_mean
        learning_rate
        prior_mean
        prior_variance
        latent_mean
        latent_variance

    Other arguments:
        --upload, -u: upload plot to imgur and print link to console (flag)
        --gap, -g: smoothing factor (int, 1 or above)
        --output_name, -o: output filename (str, default is plot.png)
        --max_x, -x: limit x axis (int, batches)
"""

import argparse
from collections import defaultdict
from pathlib import Path

import numpy as np
import pandas as pd

try:
    from jack.utilities import upload_to_imgur
except ImportError:
    upload_to_imgur = None
from matplotlib import pyplot as plt
from utilities.gnina_functions import condense


def get_loss_logs(filenames):
    """Recursively find loss logs generated by autoencoders."""
    if filenames is not None and len(filenames):
        loss_logs = []
        dirs = [Path(f).rglob('**/loss_log.txt') for f in filenames]
        for gen in dirs:
            loss_logs += list(gen)
        return loss_logs
    else:
        return list(Path('.').rglob('**/loss_log.txt'))


def extract_data(loss_logs, fields, max_x=-1):
    """Extract numerical logs from loss logs.

    Arguments:
        loss_logs: list of text files containing numerical log data generated by
            autoencoders
        fields: types of values to plot (each gets its own subplot, e.g.
            nonzero_mae, loss, prior_mean, etc.)
        max_x: limit plots to <max_x> iterations from start

    Returns:
        dict containing mappings from each field (e.g. nonzero_mae, loss,
        prior_mean, etc.) to a dict of directories (denoting different
        autoencoders), which in turn map to numpy arrays containing the values
        associated with that field and autoencoder.

    Raises:
        RuntimeException if a field specified is not found.
    """
    data = defaultdict(dict)
    extra_info = defaultdict(dict)
    for loss_log in loss_logs:
        exp = '/'.join(str(loss_log).split('/')[-5:])
        config = loss_log.parent / 'config'
        skip = False
        with open(config, 'r') as f:
            for line in f.readlines():
                param = line.split()[0]
                value = line.split()[1]
                if param == 'adversarial_variance':
                    extra_info[exp][param] = float(value)
                if param == 'densefs':
                    skip = True
                    break
        if skip:
            continue
        print(loss_log.parent)
        df = pd.read_csv(loss_log, sep=' ')
        for field in fields:
            try:
                if max_x > 0:
                    data[field][exp] = df[field].to_numpy()[:max_x]
                else:
                    data[field][exp] = df[field].to_numpy()
            except KeyError:
                raise RuntimeError('{} not found.'.format(field))
    return data, extra_info


def plot_ax(data, field, gap, ax, extra_info=None, colours=None):
    """Plot all data associated with a given field for all autoencoders.

    Arguments:
         data: dict -> dict -> numpy array (result of extract_data)
         field: the title of the values to be plotted (nonzero_mae, loss, etc.)
         gap: smoothing factor (1 or greater)
         ax: matplotlib subplot ax to draw on
         extra_info: dict of dicts containing information about adversarial
            constraints of the format {field: {experiment}}
         colours: iterable of matplotlib colour codes to use first (e.g.
            ['k', 'b', 'r']).

    Returns:
        Tuple with max and min y values for all values in data for the specified
        field across different autoencoders.
    """
    max_y = -np.inf
    min_y = np.inf
    for idx, (exp, y) in enumerate(data[field].items()):
        line_marker = '-'
        if len(set(y)) == 1:
            continue
        if isinstance(colours, list):
            if idx < len(colours):
                line_marker = colours[idx] + line_marker
        x, condensed_y = condense(y, gap)
        if 'variance' in field:
            trunc_x = len(x) // 100
            mean_value = extra_info.get(exp, {}).get('adversarial_variance')
            if mean_value is not None:
                ax.axhline(mean_value, color='k', linestyle='--')
        else:
            trunc_x = 0
            if field == 'latent_mean':
                ax.axhline(0.0, color='k', linestyle='--')
            elif field == 'ks_p_value':
                ax.axhline(0.05, color='k', linestyle='--')
        ax.plot(x, condensed_y, line_marker, label=exp)
        max_y = max(max_y, np.amax(condensed_y[trunc_x:]))
        min_y = min(min_y, np.amin(condensed_y[trunc_x:]))

    if min_y >= 0:
        ax.set_ylim([-0.1 * min_y, 1.05 * max_y])
    else:
        ax.set_ylim([1.05 * min_y, 1.05 * max_y])
    ax.legend()
    ax.grid()
    ax.set_title(field)
    if max_y > -np.inf:
        return max_y, min_y
    return None, None


def plot(filenames, fields, gap, max_x=-1, upload=False, colours=None):
    """Plot data from all fields in subplots of same fig."""
    loss_logs = get_loss_logs(filenames)
    data, extra_info = extract_data(loss_logs, fields, max_x)
    n_fields = len(fields)
    if n_fields == 1:
        fig, ax = plt.subplots(1, 1, figsize=(8, 5))
        axes = tuple([ax])
    else:
        cols = (n_fields + 1) // 2
        width = cols * 10
        fig, axes = plt.subplots(2, cols, figsize=(width, 10), sharex='all')
    ax_dict = {}
    for idx, field in enumerate(fields):
        col = idx // 2
        row = idx % 2
        if len(fields) > 2:
            ax = axes[row, col]
        else:
            ax = axes[col]
        max_y, min_y = plot_ax(
            data, field, gap, ax, extra_info=extra_info, colours=colours)
        ax_dict[field] = (ax, max_y, min_y)
    mean_max_y, mean_min_y = -np.inf, np.inf
    var_max_y, var_min_y = -np.inf, np.inf
    for field in fields:
        if ax_dict[field][1] is None:
            continue
        if field.endswith('_mean'):
            mean_max_y = max(mean_max_y, ax_dict[field][1])
            mean_min_y = min(mean_min_y, ax_dict[field][2])
        if field.endswith('_variance'):
            var_max_y = max(var_max_y, ax_dict[field][1])
            var_min_y = min(var_min_y, ax_dict[field][2])

    var_max_y = min(var_max_y, 50)
    for field in fields:
        if ax_dict[field][1] is None:
            continue
        if field.endswith('_mean'):
            if mean_min_y >= 0:
                ax_dict[field][0].set_ylim(
                    [-0.05 * mean_min_y, 1.05 * mean_max_y])
            else:
                ax_dict[field][0].set_ylim(
                    [1.05 * mean_min_y, 1.05 * mean_max_y])
        if field.endswith('_variance'):
            if var_min_y >= 0:
                ax_dict[field][0].set_ylim(
                    [-0.05 * var_min_y, 1.05 * var_max_y])
            else:
                ax_dict[field][0].set_ylim(
                    [1.05 * var_min_y, 1.05 * var_max_y])

    plt.tight_layout()
    plt.savefig(output_fname)
    if upload:
        print(upload_to_imgur(output_fname))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('filename', nargs='*', type=str)
    parser.add_argument('--output_name', '-o', type=str, required=False,
                        default='plot.png')
    parser.add_argument('--max_x', '-x', type=int, required=False, default=-1)
    parser.add_argument('--upload', '-u', action='store_true')
    parser.add_argument('--gap', '-g', type=int, default=100, required=False)
    parser.add_argument('--fields', '-f', nargs='*', type=str,
                        default='nonzero_mae')
    parser.add_argument('--colours', '-c', nargs='*', type=str, default=None)

    args = parser.parse_args()
    filenames = args.filename
    fields = [args.fields] if isinstance(args.fields, str) else args.fields
    cols = [args.colours] if isinstance(args.colours, str) else args.colours
    output_fname = args.output_name
    max_x = args.max_x
    upload = args.upload if upload_to_imgur is not None else False
    gap = args.gap

    plt.rc('font', family='serif')

    plot(filenames, fields, gap=gap, max_x=max_x, upload=upload, colours=cols)
